{"meta":{"title":"郭晋宇的技术博客","subtitle":"0.2+0.4=0.6000000000000001","description":null,"author":"郭晋宇","url":"//guojinyu.com"},"pages":[],"posts":[{"title":"Android HTTPS正传","slug":"Android HTTPS正传","date":"2017-04-05T14:00:00.000Z","updated":"2017-04-06T08:32:27.000Z","comments":true,"path":"2017/04/05/Android HTTPS正传/","link":"","permalink":"//guojinyu.com/2017/04/05/Android HTTPS正传/","excerpt":"","text":"随着HTTPS的越来越普及，我们在客户端开发过程中越来越多的被要求从HTTP转换为HTTPS，纵然你开发的是普通APP而非浏览器，正确的编写HTTPS网络代码也是至关重要的。但现实是，大部分的HTTPS相关代码中总是存在各种各样的问题，这些问题使得我们的APP在网络通信中存在严重的漏洞，从而丧失了使用HTTPS的意义。 因此，本文将从以下三个方面来展开介绍，一是对于HTTPS的理解；二是常见的HTTPS的使用误区；三是如何编写正确的HTTPS通信代码，包括使用HttpClient或HttpUrlConnection。 HTTPS的理解熟悉的读者可以直接跳过，简单来说HTTPS=HTTP+SSL/TLS，而SSL/TLS=加密+认证+完整性保护，HTTPS协议简单理解就是在进行传统的HTTP通信之前先通过SSL/TLS协议握手建立安全的通道。 其实SSL/TLS说白了就是密码学里的一个混合密码系统，用对称加密来保护机密性，用消息认证码(MAC)来做认证和完整性保护，同时为了解决对称密码的密钥配送问题，采用了公钥加密方法，那么为了保证公钥的合法性，就由认证机构(CA)来对公钥及相关信息进行数字签名，即我们口中的证书。 其实不只是HTTPS，很多应用层的网络传输协议为了保证安全都和SSL/TLS进行了联姻，如FTPS，采用SSL/TLS的IMAP、POP3/SMTP、Telnet协议等。 HTTPS的使用误区Android APP在HTTPS上存在的最大问题就是中间人攻击漏洞，所谓中间人攻击，就是攻击人介入到通信双方的中间，假冒彼此与对方就行通信，从而套取隐私信息。而导致这一漏洞的最大的原因，就是代码中对HTTPS证书的不合理使用，确切地说，就是客户端没有校验服务端的HTTPS证书（包含签名CA是否合法、域名是否匹配、是否自签名证书、证书是否过期，此处建议认真阅读Android HTTPS中间人劫持漏洞浅析这篇博文，通俗易懂）。 常见于以下两种情况： 1.自定义X509TrustManager但是没有对SSL证书进行校验，如checkServerTrusted()方法实现为空，即不检查服务器是否可信； 2.没有对域名进行校验，如使用setHostnameVerifier(ALLOW_ALL_HOSTNAME_VERIFIER)或使用自定义HostnameVerifier但是verify()方法返回始终为True，即不校验域名。 开发人员这样写的目的往往是规避SSL异常，但是不仅没有发挥HTTPS的能力反而暴露出了漏洞。 当然，导致中间人攻击的原因可能还有其他，如CA被攻击导致私钥被盗等等，这种情况不在本文讨论范围内。 HTTPS的正确实现如何正确地实现HTTPS，关键在于如何正确地处理证书。 前文提到，证书认证机构CA会对我们HTTPS通信中用到的公钥进行签名来制作证书，其实就是服务器有一套公私钥，CA也有一套公私钥，CA要用它的私钥对我们的公钥就行数字签名，此即为认证。所以一份证书的主要内容便是三部分，a、服务器生成的公钥，b、申请证书时填写的一些相关信息，c、CA用自己的私钥对a和b内容生成的数字签名。那么当客户端在验证服务端的证书时，客户端必须拥有证书CA的公钥，才能去验证签名。 所以根据客户端是否拥有CA的公钥，处理证书便分为以下几种情况： 1. CA是受信任的这是HTTPS使用中最推荐的方式，即使用知名的证书颁发机构如Symantec(收购了VeriSign)，这类颁发机构一般在浏览器或者Android系统内置的信任CA列表里，这就意味着客户端拥有该CA的公钥，可以直接按照HTTPS握手协议从服务端获取证书，并对该CA认证的证书进行验签，获取服务端公钥。当然不足就是此类证书可能是需要收费的。 代码实现如下： HttpURLConnection(该API在Android 4.4版本及以后已替换为OkHttp实现) 123456789101112HttpURLConnection urlConnection = null;try &#123; URL url = new URL(\"https://www.baidu.com\"); urlConnection = (HttpURLConnection) url.openConnection(); InputStream in = urlConnection.getInputStream();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; if (urlConnection != null) &#123; urlConnection.disconnect(); &#125;&#125; 这种情况代码实现简单，其实和使用普通的HTTP没有任何区别，因为当url是HTTPS格式时，url.openConnection()返回的实际是HttpsURLConnection对象。 HttpClient(Android 6.0版本及以后已去除该框架) 1234567891011HttpClient httpClient = new DefaultHttpClient();HttpGet httpGet = new HttpGet(\"https://www.baidu.com/\");try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200)&#123; HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity,\"utf-8\"); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 同样和HTTP代码的编写没有任何区别。 我们这里说的第一种方式前提是颁发证书的CA是受信任的，即使用HTTPS协议的设备或浏览器已信任目标服务端证书的签名机构。可以看到这种情况下代码的编写很简单，但是，在日常Android开发中，如此简单的方式未必能覆盖我们的需求，为什么这样说呢？由于Android碎片化现象的严重，不同版本不同设备信任的CA列表可能不尽相同，所以往往会出现一套代码在这个设备上运行正常，但在另一个设备上就javax.net.ssl.SSLException了。 2. 未知的CA所谓未知的CA包含三种情况，一是设备未添加到信任列表的公共CA，二是政府、公司或教育机构等组织发放的私有CA(国内很常见，如12306网站的证书)，三是自签名的证书(这种情况严格来说并不是CA的认证，而是自己使用Keytool或OpenSSL签发证书，好比自己是自己的CA)。由于这三种情况在开发中的处理差别不大，因此归为一类。对于此类CA，通常的做法是本地内置CA证书文件或内容字符串。 HttpURLConnection 1234567891011121314151617181920212223242526272829303132333435363738InputStream caInput = null;Certificate ca = null;try &#123; // Load CAs from an InputStream // (could be from a resource or ByteArrayInputStream or ...) CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); caInput = context.getAssets().open(\"srca.cer\"); ca = cf.generateCertificate(caInput);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; caInput.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;try &#123; // Create a KeyStore containing our trusted CAs String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(\"ca\", ca); // Create a TrustManager that trusts the CAs in our KeyStore String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); // Create an SSLContext that uses our TrustManager SSLContext sslContext = SSLContext.getInstance(\"TLS\"); sslContext.init(null, tmf.getTrustManagers(), null); // Tell the URLConnection to use a SocketFactory from our SSLContext URL url = new URL(\"https://kyfw.12306.cn/otn/\"); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); urlConnection.setSSLSocketFactory(sslContext.getSocketFactory()); InputStream in = urlConnection.getInputStream();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 上面代码中srca.cer证书文件是从12306官网下载的，当然也可以获取到证书内容并在代码里定义为字符串常量。 HttpClient 12345678910111213141516171819202122232425262728293031323334353637InputStream caInput = null;Certificate ca = null;try &#123; // Load CAs from an InputStream // (could be from a resource or ByteArrayInputStream or ...) CertificateFactory cf = CertificateFactory.getInstance(\"X.509\"); caInput = context.getAssets().open(\"srca.cer\"); ca = cf.generateCertificate(caInput);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; caInput.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;try &#123; // Create a KeyStore containing our trusted CAs String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(\"ca\", ca); SSLSocketFactory ssl = new SSLSocketFactory(keyStore); ssl.setHostnameVerifier(ssl.getHostnameVerifier()); Scheme scheme = new Scheme(\"https\", ssl, 443); HttpClient httpclient = new DefaultHttpClient(); httpclient.getConnectionManager().getSchemeRegistry().register(scheme); HttpGet httpGet = new HttpGet(\"https://kyfw.12306.cn/otn/\"); HttpResponse httpResponse = httpclient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) &#123; HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, \"utf-8\"); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 与HttpURLConnection相比，其实代码套路基本一致，都是先读取证书生成一个Certificate对象，然后根据证书构建KeyStore对象，最后构建SSLSocketFactory对象并和HTTP协议关联起来。 3. 缺少中间CA何谓缺少中间证书颁发机构？其实大多数公共CA不直接签署服务器证书，而是使用自己的根CA签署中间 CA，然后用中间CA去满足我们的证书签发的请求，以降低根CA泄露风险。那么问题来了，Android 等操作系统通常仅直接信任根CA，因此中间CA就又变成了未知CA。解决这个问题主要有两个办法，分别为服务端解决和客户端解决（参考谷歌官方文档通过HTTPS和SSL确保安全）。 服务端配置服务器以便在服务器链中添加中间CA，使得服务器在SSL 握手期间不只向客户端发送它的证书，而是发送一个证书链，包括服务器CA以及到达可信的根CA所需要的任意中间证书。 客户端不用我说大家都知道了吧，按照前文，像对待其他任何未知CA一样对待中间CA。 对于Android开发中HTTPS的实现方式，本文分HttpURLConnection和HttpClient两套框架分别做了讲解，但实际上我们用到更多的可能是其他的一些HTTP协议开源框架，如okhttp、retrofit、volley、android-async-http等，其实万变不离其宗，这些框架大多是互相包含的关系，因此在HTTPS使用上也没有太大差别，顶多就是有些已经做了一定程度的封装，网上相关的资料也有很多，只要理解其背后的含义，相信都不难实现。 此外，在实际的HTTPS开发中我们遇到的需求或者问题可能千奇百怪，有时候我们不得不通过自定义TrustManager或HostnameVerifier来实现，但是切记这是有风险的，一定要尽可能地完成校验（签名CA是否合法、域名是否匹配、是否自签名证书、证书是否过期），在力所能及的范围内写出最为安全的代码。 文中所有代码可以在个人github主页查看和下载。 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"}]},{"title":"Android屏幕适配与资源匹配","slug":"Android屏幕适配与资源匹配","date":"2016-12-19T07:42:00.000Z","updated":"2017-02-21T08:42:28.000Z","comments":true,"path":"2016/12/19/Android屏幕适配与资源匹配/","link":"","permalink":"//guojinyu.com/2016/12/19/Android屏幕适配与资源匹配/","excerpt":"","text":"Android屏幕适配是个头疼的问题，同时关于这方面的讲解也是烂大街了，那么为什么还要写这篇博文呢，一方面是想基于Google官方教程和个人开发中的经验总结一份准确精炼的教程，另一方面也是作为一个知识备份。 那么，通过本文你可以学到以下这些： 1.Android界面开发中的那些名词的概念2.如何和一名不懂Android的UI设计师合作3.Android如何进行资源匹配 对应以下三块内容： 名词解释pxpx(pixel)即像素，没什么好说的，所有电子图形设备能够显示的最小粒度的单位，和尺寸什么的无关，一般设备每一个像素点都是一个正方形。我们常说的1080p或者2k屏就是指的像素。 inchinch即英寸，没啥好说的，一般我们所说的几寸屏就是指的屏幕对角线是几英寸。Android曾经将屏幕尺寸组概括为四种：small、normal、large和xlarge，但是自Android 3.2(API=13)开始，这套尺寸组已弃用，而采用根据可用屏幕宽度管理屏幕尺寸的新技术。 dpidpi(dots per inch)即每英寸的像素点的个数，这个值可以表示屏幕密度。Android目前把所有的屏幕密度归纳为六种通用dpi： ldpi ～120dpimdpi ～160dpi (baseline)hdpi ～240dpixhdpi ～320dpixxhdpi ～480dpixxxhdpi ～640dpi 需要说明的是，上面的每种规格都只是圈定了一个范围，近似于后面的dpi数值，比如对于两台声明自己是hdpi屏幕密度的设备，其实际dpi值可能略有不同。此外，Android官方把mdpi定为基准(baseline)，这个基准有什么用呢，后面就可以看到了。 densitydensity是真正意义上的屏幕密度，density=dpi/160，160是什么呢？正是我们上面说的基准mdpi的dpi值。在开发中可以由以下代码得到：1getResources().getDisplayMetrics().density; dpdp或dip(device independent pixels)即设备独立像素，Android特有的尺寸度量单位，设计的目的就是让其值在不同屏幕密度下能保持统一。在基准密度mdpi下，1dp=1px，因此dp和px的换算关系为dp=px/density=px/(dpi/160) spsp(scaled pixels),可以大致翻译为比例像素，专门用于设置文字大小，其实其他和dp一样，唯一的不同就是会随着设备字体大小的设置项的改变而变化。 如何根据UI标注的px来开发专业的UI设计师可能会给Android开发人员按照dp值来进行标注，并分几种不同的屏幕密度如hdpi、xhdpi来准备两套以上切图。但是很多“iOS系”的设计师会直接按照iPhone的模版来出图，并且按照iOS惯用的px来标注，然后发给一脸懵逼的我们。这个时候我们要去知道UI设计所采用的界面分辨率(720p?1080p?)是多少，当然最好也要知道目标设备屏幕尺寸是多少，比如同样是1080p，手机和平板的屏幕尺寸可是要差很大的。总而言之，我们是要确定依照哪种屏幕密度(hdpi?xhdpi?)来处理这套标注与切图。靠什么呢，靠下面这个主流机型屏幕尺寸表来映射吧(即使不知道具体的目标屏幕尺寸也没关系，只要知道你做的是手机还是平板应用就行了，然后基本上按照屏幕分辨率来选择吧)。 ldpi density=0.75 2.7”:240x320,3.3”:240x400,3.4”:240x432mdpi density=1 3.2”:320x480,5.1”:480x800,5.4”:480x854 (Tablet)7.0”:1024x600,10.1”:1280x800hdpi density=1.5 3.7”:480x800,3.7”:480x854,4.0”:480x800xhdpi density=2 4.65”:720x1280,4.7”:720x1280,4.7”:768x1280 (Tablet)7.0”:1200x1920,8.9”:2048x1536,10.1”:2560x1600xxhdpi density=3 5.0”:1080x1920560dpi 5.7”:1400*2560 一般UI设计师在设计手机APP时，除了按照iPhone的尺寸来出图，可能比较常用的是720x1280或者1080x1920这两个分辨率，那么若是720x1280px，我们就可以直接按照xhdpi来将标注图上的px值转化为dp，dp=px/density=px/2，然后所有对应的切图也就不用犹豫，直接丢入到drawable-xhdpi里即可；同理，若是1080x1920px，按照xxhdpi来处理，等等。需要说明的是，很多网上的教程在屏幕适配方面建议每个尺寸的资源文件夹都放入一套资源文件，或者建议只准备一套hdpi的资源文件。这都不是很合理的，前者的话可能对于一些比较特殊或者重要的素材需要这样处理，否则的话这会大大增加apk文件的体积，因此对于要求不是特别高的情况，只准备一至两套即可，Android系统在显示图片的时候会根据自身dpi和素材所在drawable文件夹的dpi来自动进行放大或缩小；后者的话已经过时了，时代在进步，社会在发展，现在市场上的主流机型是大屏手机了，目前应该是xhdpi和xxhdpi为主流，因此在设计和准备图片资源的时候最好围绕这二者来做，当然，仅限于当下。 Android如何进行最佳资源匹配在运行时，Android会检测当前设备配置并为应用加载合适的资源。那么Android如何去寻找它所认为的最合适的资源呢？假设有很多drawable目录分别包含相同图片资源的不同版本，那么参照以下流程图，匹配的过程如下： 1.淘汰与设备配置冲突的资源文件何谓与设备配置冲突的资源文件，这就不得不提到资源限定符了，比如我们默认生成的资源文件夹drawable-hdpi/中的hdpi就是一种限定符，实际上，限定符克不止屏幕像素密度这一种类型而是有很多，比如语言，屏幕方向，夜间模式，文本输入法，API级别等等十多种，如果要使用这些限定符则必须按照官方定义的规则去排序，比如drawable-en-port-xhdpi-12key/，顺序错误的话该资源文件夹会被忽略。理解了资源限定符这个概念，那么这一步就好理解了，那就是Android系统会根据当前设备的一系列配置去淘汰掉存在不匹配的资源限定符的文件夹，如语言不匹配或屏幕方向不匹配等等，但是要注意，屏幕像素密度是唯一一个不会因冲突而被淘汰的限定符。比如尽管设备的屏幕密度为hdpi，但是drawable-port-ldpi/不会被淘汰，因为此时每个屏幕密度均视为匹配。 2.双重循环(第一层遍历资源限定符，第二层遍历资源文件夹)按照限定符的优先级顺序选取下一个限定符，然后查找是否有资源目录包含此限定符，都没有的话换下一个限定符，如果有的话淘汰掉不含该限定符的资源文件夹，在剩余的资源文件夹里再匹配下一个限定符。可想而知，一般情况下，通过这样一个双重循环匹配，最终会只剩一个资源目录，便是最合适的资源。不一般的情况往下看。 3.特殊情况在步骤2中有一个例外，如果资源限定符的遍历走到了屏幕像素密度这一步，又没有完全匹配的资源文件夹，则Android会按比例缩小更高密度的资源或者放大更低密度的资源，比例系数为期望的dpi标准与实际的dpi标准的比值。就目前查找到的资料显示，通常，Android会选择一个能达到最佳效果的资源文件，因此它倾向于缩小大型原始图像，而不是放大小型原始图像。例如，设备是ldpi属性，但目前可用的资源文件有mdpi和hdpi版本，系统会优先选择缩小hdpi版本，因为系统可轻松以0.5为系数将hdpi资源缩小至ldpi资源，与以0.75为系数缩小mdpi中密度资源相比，伪影更少。此外，还有一点需要说明的是，系统会将drawable/ 中的资源作为“默认”资源，也就是指未标记配置限定符的资源，系统假设默认资源设计用于基线屏幕尺寸和密度，即mpdi，并在没有更合适的资源文件夹的情况下选择该文件夹中的资源，因此你的图片资源文件最好不要放置在该文件夹里，而是要放置在指定dpi的文件夹里。 Ref:1.支持多种屏幕2.提供资源 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"}]},{"title":"Android二维码扫描的简单实现及源码分析","slug":"Android二维码扫描的简单实现及源码分析","date":"2016-12-07T11:30:00.000Z","updated":"2017-05-19T05:16:30.000Z","comments":true,"path":"2016/12/07/Android二维码扫描的简单实现及源码分析/","link":"","permalink":"//guojinyu.com/2016/12/07/Android二维码扫描的简单实现及源码分析/","excerpt":"","text":"二维码扫描最近两年简直是风靡移动互联网时代，尤其在国内发展神速。围绕条码扫码功能，首先说说通过本文你可以知道啥。一，如何在你的APP中快速集成一维码、二维码扫描功能；二，大概了解条码扫描功能的实现原理以及理解各个模块的代码。但是，本文不包含条码的编解码原理，如有兴趣，请自行查阅。 条码扫描功能的快速集成默认你使用了Android Stuidio进行开发，直接使用这个开源项目SimpleZXing,它是在ZXing库的作者为Android写的条码扫描APP Barcode Scanner的基础上精简和修改而成的。你可以通过简单的两步就可以实现条码扫描的功能。 1.添加项目依赖 1compile 'com.acker:simplezxing:1.3' 2.在你想调起条码扫描界面的地方(比如YourActivity)，调起二维码扫描界面CaptureActivity 1startActivityForResult(new Intent(YourActivity.this, CaptureActivity.class), CaptureActivity.REQ_CODE) 然后就会打开如下这个界面： 将条码置于框内，扫描成功后会将解码得到的字符串返回给调起者，所以你只需要在你的Activity的onActivityResult()方法里拿到它进行后续操作即可。 当然SimpleZXing目前还支持一些设置项，包括摄像头是否开启曝光，扫码成功后是否震动，是否发声，闪光灯模式自动、常开、常关，屏幕自动旋转、横屏、竖屏。 同时，虽然该项目已经在manifest里申明了所需的照相机权限，但是在Android 6.0以上系统中你仍然需要自己处理动态权限管理。所以一个标准的使用方式如以下代码所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.acker.simplezxing.demo;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import com.acker.simplezxing.activity.CaptureActivity;public class MainActivity extends AppCompatActivity &#123; private static final int REQ_CODE_PERMISSION = 0x1111; private TextView tvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvResult = (TextView) findViewById(R.id.tv_result); Button btn = (Button) findViewById(R.id.btn_sm); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // Open Scan Activity if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; // Do not have the permission of camera, request it. ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQ_CODE_PERMISSION); &#125; else &#123; // Have gotten the permission startCaptureActivityForResult(); &#125; &#125; &#125;); &#125; private void startCaptureActivityForResult() &#123; Intent intent = new Intent(MainActivity.this, CaptureActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(CaptureActivity.KEY_NEED_BEEP, CaptureActivity.VALUE_BEEP); bundle.putBoolean(CaptureActivity.KEY_NEED_VIBRATION, CaptureActivity.VALUE_VIBRATION); bundle.putBoolean(CaptureActivity.KEY_NEED_EXPOSURE, CaptureActivity.VALUE_NO_EXPOSURE); bundle.putByte(CaptureActivity.KEY_FLASHLIGHT_MODE, CaptureActivity.VALUE_FLASHLIGHT_OFF); bundle.putByte(CaptureActivity.KEY_ORIENTATION_MODE, CaptureActivity.VALUE_ORIENTATION_AUTO); intent.putExtra(CaptureActivity.EXTRA_SETTING_BUNDLE, bundle); startActivityForResult(intent, CaptureActivity.REQ_CODE); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case REQ_CODE_PERMISSION: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // User agree the permission startCaptureActivityForResult(); &#125; else &#123; // User disagree the permission Toast.makeText(this, \"You must agree the camera permission request before you use the code scan function\", Toast.LENGTH_LONG).show(); &#125; &#125; break; &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case CaptureActivity.REQ_CODE: switch (resultCode) &#123; case RESULT_OK: tvResult.setText(data.getStringExtra(CaptureActivity.EXTRA_SCAN_RESULT)); //or do sth break; case RESULT_CANCELED: if (data != null) &#123; // for some reason camera is not working correctly tvResult.setText(data.getStringExtra(CaptureActivity.EXTRA_SCAN_RESULT)); &#125; break; &#125; break; &#125; &#125;&#125; 以上说了如何通过使用SimpleZXing开源项目来快速实现条码扫描功能，当然开发者可能会因为一些特定的需求需要修改某些地方的代码，如UI等等，那么下面我会带大家大致讲解一下这个开源项目的代码，使大家更进一步了解条码扫描的实现机制，同时方便大家在它基础之上进行修改。 SimpleZXing关键代码分析其实条码扫描的过程很容易理解，就是将摄像头捕捉到的预览帧数组进行处理，发现其中的一维码或二维码并进行解码。但是就是在摄像头捕捉数据的过程中有几个重要的地方需要大家注意。我们倒过来分析这个过程。 1.DecodeHandler.class中的decode()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Decode the data within the viewfinder rectangle, and time how long it took. For efficiency, * reuse the same reader objects from one decode to the next. * * @param data The YUV preview frame. * @param width The width of the preview frame. * @param height The height of the preview frame. */private void decode(byte[] data, int width, int height) &#123; long start = System.currentTimeMillis(); if (width &lt; height) &#123; // portrait byte[] rotatedData = new byte[data.length]; for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) rotatedData[y * width + width - x - 1] = data[y + x * height]; &#125; data = rotatedData; &#125; Result rawResult = null; PlanarYUVLuminanceSource source = activity.getCameraManager().buildLuminanceSource(data, width, height); if (source != null) &#123; BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); try &#123; rawResult = multiFormatReader.decodeWithState(bitmap); &#125; catch (ReaderException re) &#123; // continue &#125; finally &#123; multiFormatReader.reset(); &#125; &#125; Handler handler = activity.getHandler(); if (rawResult != null) &#123; // Don't log the barcode contents for security. long end = System.currentTimeMillis(); Log.d(TAG, \"Found barcode in \" + (end - start) + \" ms\"); if (handler != null) &#123; Message message = Message.obtain(handler, R.id.decode_succeeded, rawResult); message.sendToTarget(); &#125; &#125; else &#123; if (handler != null) &#123; Message message = Message.obtain(handler, R.id.decode_failed); message.sendToTarget(); &#125; &#125;&#125; 显然，这个时候处理解码的线程对应的Handler已经拿到了预览帧的byte数组以及预览帧的高和宽。在这个方法中，我们首先根据此时屏幕是横屏还是竖屏对预览帧数组进行了一个预处理。 因为在Android设备上，存在以下几个概念： 屏幕方向：在Android系统中，屏幕的左上角是坐标系统的原点（0,0）坐标。原点向右延伸是X轴正方向，原点向下延伸是Y轴正方向。 相机传感器方向：手机相机的图像数据都是来自于摄像头硬件的图像传感器，这个传感器在被固定到手机上后有一个默认的取景方向，坐标原点位于手机横放时的左上角，即与横屏应用的屏幕X方向一致。换句话说，与竖屏应用的屏幕X方向呈90度角。 相机的预览方向：由于手机屏幕可以360度旋转，为了保证用户无论怎么旋转手机都能看到“正确”的预览画面（这个“正确”是指显示在UI预览界面的画面与人眼看到的眼前的画面是一致的），Android系统底层根据当前手机屏幕的方向对图像传感器采集到的数据进行了旋转处理，然后才送给显示系统，因此可以保证预览画面始终“正确”。在相机API中可以通过setDisplayOrientation()设置相机预览方向。在默认情况下，这个值为0，与图像传感器一致。因此对于横屏应用来说，由于屏幕方向和预览方向一致，预览图像不会颠倒90度。但是对于竖屏应用，屏幕方向和预览方向垂直，所以会出现颠倒90度现象。为了得到正确的预览画面，必须通过API将相机的预览方向旋转90，保持与屏幕方向一致，如图3所示。 也就是说，相机得到的图像数据始终是一个横屏的姿态，当手机处于竖屏时，即使我们通过设置在屏幕上看到的拍摄画面是准确的，没有90度翻转的，我们通过API得到的图像数据仍然是基于横屏的，因此在判断到width &lt; height即屏幕处于竖屏状态时，我们首先对byte数组进行一个手动90度旋转，然后将结果构造为一个PlanarYUVLuminanceSource对象，进行真正的解析处理去了，这里我们就不管了。 然后再看这个预览帧数据是怎么来的。 2.PreviewCallback.class中的onPreviewFrame()方法12345678910111213141516171819202122@Overridepublic void onPreviewFrame(byte[] data, Camera camera) &#123; Point cameraResolution = configManager.getCameraResolution(); Handler thePreviewHandler = previewHandler; if (cameraResolution != null &amp;&amp; thePreviewHandler != null) &#123; Message message; Point screenResolution = configManager.getScreenResolution(); if (screenResolution.x &lt; screenResolution.y)&#123; // portrait message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.y, cameraResolution.x, data); &#125; else &#123; // landscape message = thePreviewHandler.obtainMessage(previewMessage, cameraResolution.x, cameraResolution.y, data); &#125; message.sendToTarget(); previewHandler = null; &#125; else &#123; Log.d(TAG, \"Got preview callback, but no handler or resolution available\"); &#125;&#125; 这个容易理解，就是系统Camera.PreviewCallback接口，并实现了回调方法，每次获取到预览帧时将图像数据进行回调，同样区分了横竖屏的情况以方便上文decode时的预处理。这里出现了cameraResolution和screenResolution两个对象，我们接下来看看它们分别是什么。 3.CameraConfigurationManager.class中的initFromCameraParameters()方法我们可以看到，上面提到的cameraResolution和screenResolution是在CameraConfigurationManager.class中的initFromCameraParameters()方法中得到的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Reads, one time, values from the camera that are needed by the app. */void initFromCameraParameters(OpenCamera camera) &#123; Camera.Parameters parameters = camera.getCamera().getParameters(); WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = manager.getDefaultDisplay(); int displayRotation = display.getRotation(); int cwRotationFromNaturalToDisplay; switch (displayRotation) &#123; case Surface.ROTATION_0: cwRotationFromNaturalToDisplay = 0; break; case Surface.ROTATION_90: cwRotationFromNaturalToDisplay = 90; break; case Surface.ROTATION_180: cwRotationFromNaturalToDisplay = 180; break; case Surface.ROTATION_270: cwRotationFromNaturalToDisplay = 270; break; default: // Have seen this return incorrect values like -90 if (displayRotation % 90 == 0) &#123; cwRotationFromNaturalToDisplay = (360 + displayRotation) % 360; &#125; else &#123; throw new IllegalArgumentException(\"Bad rotation: \" + displayRotation); &#125; &#125; Log.i(TAG, \"Display at: \" + cwRotationFromNaturalToDisplay); int cwRotationFromNaturalToCamera = camera.getOrientation(); Log.i(TAG, \"Camera at: \" + cwRotationFromNaturalToCamera); // Still not 100% sure about this. But acts like we need to flip this: if (camera.getFacing() == CameraFacing.FRONT) &#123; cwRotationFromNaturalToCamera = (360 - cwRotationFromNaturalToCamera) % 360; Log.i(TAG, \"Front camera overriden to: \" + cwRotationFromNaturalToCamera); &#125; cwRotationFromDisplayToCamera = (360 + cwRotationFromNaturalToCamera - cwRotationFromNaturalToDisplay) % 360; Log.i(TAG, \"Final display orientation: \" + cwRotationFromDisplayToCamera); int cwNeededRotation; if (camera.getFacing() == CameraFacing.FRONT) &#123; Log.i(TAG, \"Compensating rotation for front camera\"); cwNeededRotation = (360 - cwRotationFromDisplayToCamera) % 360; &#125; else &#123; cwNeededRotation = cwRotationFromDisplayToCamera; &#125; Log.i(TAG, \"Clockwise rotation from display to camera: \" + cwNeededRotation); Point theScreenResolution = new Point(); display.getSize(theScreenResolution); screenResolution = theScreenResolution; Log.i(TAG, \"Screen resolution in current orientation: \" + screenResolution); cameraResolution = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution); Log.i(TAG, \"Camera resolution: \" + cameraResolution); bestPreviewSize = CameraConfigurationUtils.findBestPreviewSizeValue(parameters, screenResolution); Log.i(TAG, \"Best available preview size: \" + bestPreviewSize);&#125; 这个方法中前面的大段通过屏幕方向和摄像头成像方向来计算预览画面的旋转度数，从而保证预览得到的画面随着手机的旋转或者前后置摄像头的更换而保持正确的显示，当然，我们也可以看到screenResolution是通过Display类来获取到的Point对象。它的x，y值就分别代表当前屏幕的横向和纵向的像素值，当然这个是和屏幕方向有关系的。然后可以看到另外两个Point对象cameraResolution以及bestPreviewSize是通过CameraConfigurationUtils.class中的findBestPreviewSizeValue()方法得到的，那我们再来看这个方法。 4.CameraConfigurationUtils.class中的findBestPreviewSizeValue()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static Point findBestPreviewSizeValue(Camera.Parameters parameters, Point screenResolution) &#123; List&lt;Camera.Size&gt; rawSupportedSizes = parameters.getSupportedPreviewSizes(); if (rawSupportedSizes == null) &#123; Log.w(TAG, \"Device returned no supported preview sizes; using default\"); Camera.Size defaultSize = parameters.getPreviewSize(); if (defaultSize == null) &#123; throw new IllegalStateException(\"Parameters contained no preview size!\"); &#125; return new Point(defaultSize.width, defaultSize.height); &#125; // Sort by size, descending List&lt;Camera.Size&gt; supportedPreviewSizes = new ArrayList&lt;&gt;(rawSupportedSizes); Collections.sort(supportedPreviewSizes, new Comparator&lt;Camera.Size&gt;() &#123; @Override public int compare(Camera.Size a, Camera.Size b) &#123; int aPixels = a.height * a.width; int bPixels = b.height * b.width; if (bPixels &lt; aPixels) &#123; return -1; &#125; if (bPixels &gt; aPixels) &#123; return 1; &#125; return 0; &#125; &#125;); if (Log.isLoggable(TAG, Log.INFO)) &#123; StringBuilder previewSizesString = new StringBuilder(); for (Camera.Size supportedPreviewSize : supportedPreviewSizes) &#123; previewSizesString.append(supportedPreviewSize.width).append('x') .append(supportedPreviewSize.height).append(' '); &#125; Log.i(TAG, \"Supported preview sizes: \" + previewSizesString); &#125; double screenAspectRatio = screenResolution.x / (double) screenResolution.y; // Remove sizes that are unsuitable Iterator&lt;Camera.Size&gt; it = supportedPreviewSizes.iterator(); while (it.hasNext()) &#123; Camera.Size supportedPreviewSize = it.next(); int realWidth = supportedPreviewSize.width; int realHeight = supportedPreviewSize.height; if (realWidth * realHeight &lt; MIN_PREVIEW_PIXELS) &#123; it.remove(); continue; &#125; boolean isScreenPortrait = screenResolution.x &lt; screenResolution.y; int maybeFlippedWidth = isScreenPortrait ? realHeight : realWidth; int maybeFlippedHeight = isScreenPortrait ? realWidth : realHeight; double aspectRatio = (double) maybeFlippedWidth / (double) maybeFlippedHeight; double distortion = Math.abs(aspectRatio - screenAspectRatio); if (distortion &gt; MAX_ASPECT_DISTORTION) &#123; it.remove(); continue; &#125; if (maybeFlippedWidth == screenResolution.x &amp;&amp; maybeFlippedHeight == screenResolution.y) &#123; Point exactPoint = new Point(realWidth, realHeight); Log.i(TAG, \"Found preview size exactly matching screen size: \" + exactPoint); return exactPoint; &#125; &#125; // If no exact match, use largest preview size. This was not a great idea on older devices because // of the additional computation needed. We're likely to get here on newer Android 4+ devices, where // the CPU is much more powerful. if (!supportedPreviewSizes.isEmpty()) &#123; Camera.Size largestPreview = supportedPreviewSizes.get(0); Point largestSize = new Point(largestPreview.width, largestPreview.height); Log.i(TAG, \"Using largest suitable preview size: \" + largestSize); return largestSize; &#125; // If there is nothing at all suitable, return current preview size Camera.Size defaultPreview = parameters.getPreviewSize(); if (defaultPreview == null) &#123; throw new IllegalStateException(\"Parameters contained no preview size!\"); &#125; Point defaultSize = new Point(defaultPreview.width, defaultPreview.height); Log.i(TAG, \"No suitable preview sizes, using default: \" + defaultSize); return defaultSize;&#125; 可以看出所谓bestPreviewSize就是将相机支持的预览分辨率都获取到然后找一个和屏幕分辨率最接近的最为最终的结果，当然，同样，要有横竖屏的处理。那么上面步骤3获取到的这些Point对象等等还有什么用呢，其实它们都将作为相机预览及显示的参数设置给Camera对象，如以下这个方法： 5.CameraConfigurationManager.class中的setDesiredCameraParameters()方法123456789101112131415161718192021222324252627282930313233343536void setDesiredCameraParameters(OpenCamera camera, boolean safeMode) &#123; Camera theCamera = camera.getCamera(); Camera.Parameters parameters = theCamera.getParameters(); if (parameters == null) &#123; Log.w(TAG, \"Device error: no camera parameters are available. Proceeding without configuration.\"); return; &#125; Log.i(TAG, \"Initial camera parameters: \" + parameters.flatten()); if (safeMode) &#123; Log.w(TAG, \"In camera config safe mode -- most settings will not be honored\"); &#125; initializeTorch(parameters, safeMode); CameraConfigurationUtils.setFocus( parameters, true, true, safeMode); if (!safeMode) &#123; CameraConfigurationUtils.setBarcodeSceneMode(parameters); CameraConfigurationUtils.setVideoStabilization(parameters); CameraConfigurationUtils.setFocusArea(parameters); CameraConfigurationUtils.setMetering(parameters); &#125; parameters.setPreviewSize(bestPreviewSize.x, bestPreviewSize.y); theCamera.setParameters(parameters); theCamera.setDisplayOrientation(cwRotationFromDisplayToCamera); Camera.Parameters afterParameters = theCamera.getParameters(); Camera.Size afterSize = afterParameters.getPreviewSize(); if (afterSize != null &amp;&amp; (bestPreviewSize.x != afterSize.width || bestPreviewSize.y != afterSize.height)) &#123; Log.w(TAG, \"Camera said it supported preview size \" + bestPreviewSize.x + 'x' + bestPreviewSize.y + \", but after setting it, preview size is \" + afterSize.width + 'x' + afterSize.height); bestPreviewSize.x = afterSize.width; bestPreviewSize.y = afterSize.height; &#125;&#125; 其实很明了了，这个方法是将获取到的那些参数整合成Parameters对象set到Camera里。至此，我们大概说了两个问题，一个是如何获取并给相机设置参数，另一个是如何获取摄像头的预览数据并进行处理，接下来还有一个很重要的点需要说明，那就是我们虽然获取了整个预览帧的数据准备对其解析，但实际上，对于条码扫描来说，真正被处理的其实只是扫描框内的那部分图片或者说数据，所以我们在扫描的时候也必须将条码置于框框内，那么这就涉及到了两个部分，一个是在屏幕上绘制这样一个矩形框，另一个是在预览帧里提取框内的数据。这两点分别由以下方法实现。 6.CameraManager.getFramingRect()方法12345678910111213141516171819202122232425262728/** * Calculates the framing rect which the UI should draw to show the user where to place the * barcode. This target helps with alignment as well as forces the user to hold the device * far enough away to ensure the image will be in focus. * * @return The rectangle to draw on screen in window coordinates. */public synchronized Rect getFramingRect() &#123; if (framingRect == null) &#123; if (camera == null) &#123; return null; &#125; Point screenResolution = configManager.getScreenResolution(); if (screenResolution == null) &#123; // Called early, before init even finished return null; &#125; int width = findDesiredDimensionInRange(screenResolution.x, MIN_FRAME_WIDTH, MAX_FRAME_WIDTH); int height = findDesiredDimensionInRange(screenResolution.y, MIN_FRAME_HEIGHT, MAX_FRAME_HEIGHT); int leftOffset = (screenResolution.x - width) / 2; int topOffset = (screenResolution.y - height) / 2; framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height); Log.d(TAG, \"Calculated framing rect: \" + framingRect); &#125; return framingRect;&#125; 这个是UI中的方框Rect对象的构造，很简单了，就是根据屏幕分辨率然后按照一个固定的比例来设置方框大小。这个方法在方框的自定义View绘制时调用。 7.CameraManager.class的getFramingRectInPreview()方法12345678910111213141516171819202122232425262728293031323334353637/** * Like &#123;@link #getFramingRect&#125; but coordinates are in terms of the preview frame, * not UI / screen. * * @return &#123;@link Rect&#125; expressing barcode scan area in terms of the preview size */public synchronized Rect getFramingRectInPreview() &#123; if (framingRectInPreview == null) &#123; Rect framingRect = getFramingRect(); if (framingRect == null) &#123; return null; &#125; Rect rect = new Rect(framingRect); Point cameraResolution = configManager.getCameraResolution(); Point screenResolution = configManager.getScreenResolution(); if (cameraResolution == null || screenResolution == null) &#123; // Called early, before init even finished return null; &#125; if (screenResolution.x &lt; screenResolution.y) &#123; // portrait rect.left = rect.left * cameraResolution.y / screenResolution.x; rect.right = rect.right * cameraResolution.y / screenResolution.x; rect.top = rect.top * cameraResolution.x / screenResolution.y; rect.bottom = rect.bottom * cameraResolution.x / screenResolution.y; &#125; else &#123; // landscape rect.left = rect.left * cameraResolution.x / screenResolution.x; rect.right = rect.right * cameraResolution.x / screenResolution.x; rect.top = rect.top * cameraResolution.y / screenResolution.y; rect.bottom = rect.bottom * cameraResolution.y / screenResolution.y; &#125; framingRectInPreview = rect; &#125; return framingRectInPreview;&#125; 这个是预览帧方框Rect对象的构造，其实也很简单，就是因为相机卢兰帧分辨率和屏幕显示分辨率可能不一致，因此首先计算这两者的比例，然后再按比例对步骤6中的UI方框进行缩放，同样，计算比例的时候要区分横竖屏。这个方法是在buildLuminanceSource()中调用的，也就是步骤1中的构造PlanarYUVLuminanceSource对象时，其实还传入了这一Rect对象，来代表有效数据。 看完是不是有点点乱，因为本文没有系统的讲解，只是将所涉及内容的一些关键点比如Android Camera的使用，以及相应的横竖屏的区别处理做了介绍，真正核心的条码解码算法并没有深入，“浅尝辄止”了，就酱紫吧，有什么问题欢迎大家讨论。 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"}]},{"title":"银行POS交易流程及概念浅析","slug":"银行POS交易流程及概念浅析","date":"2016-09-18T10:58:00.000Z","updated":"2017-02-21T08:42:28.000Z","comments":true,"path":"2016/09/18/银行POS交易流程及概念浅析/","link":"","permalink":"//guojinyu.com/2016/09/18/银行POS交易流程及概念浅析/","excerpt":"","text":"银行的交易体系是一套比较复杂的系统，本文将就POS机交易涉及到的一些概念、流程等作简要介绍。 名词解释首先，解释一下我们在日常生活或者POS等支付系统开发时经常遇到的一些名词的基本概念。 1.签到签到基本上是所有POS机必须支持的一项功能，并且POS机应该在每天的使用之前进行签到操作，其目的有两个：一是保证操作员及POS机的合法性（一般签到需要输入操作员号和对应的密码，也有自动签到的模式不需要手动输入这些信息）；二是下载新的工作密钥。那么什么是工作密钥呢？ 2.工作密钥工作密钥是专门用来在交易过程中对刷卡人的卡密码进行加密的，它是在签到的时候从后台获取的，那么为了保证工作密钥的安全性，在网络传输中POS机得到的工作密钥是密文的形式，获得后需要用POS机的主密钥来解密获得真实的工作密钥明文。那么主密钥又是怎么来的呢？ 3.主密钥主密钥可以通过安全环境下手工输入或者由密钥母POS灌入等方式来存入到POS机，主要作用便是对工作密钥和MAC密钥等进行解密。 4.MAC密钥与工作密钥类似，MAC密钥也是签到时从后台获取，并且用主密钥解密，主要作用是计算MAC（数据包校验值），该校验值附加在交易报文里进行传输，收端同样计算一个MAC值，通过比较两个MAC值来确定报文是否被篡改。 5.消费消费即刷卡消费，不解释 6.消费撤销故名思意，即因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，消费撤销必须是撤销消费所用POS机的当日当批次的消费交易。 7.退货和消费撤销类似，退货也是对一笔消费交易进行退款，不同的是，一，退货不要求当日当批次的消费；二，退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款。想要理解消费撤销和退货的本质区别，那么必须首先知道什么是结算。 8.结算一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算），结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。 9.冲正当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。 10.补登补登指支付应用将交易结果发送给POS机后并没有收到POS机的应答，因此不确定POS机端是否成功记录了该笔交易，此时支付应用应进行的自动或手动的POS端交易查询。 11.预授权相关包含预授权，预授权追加，预授权完成，预授权撤销，预授权撤销完成。预授权类似于押金，即先冻结一部分用户银行卡的资金，等消费正式完成之后再扣取实际的金额即预授权完成。不难想象，预授权业务多用于酒店。 此外，POS机签购单上对应的一些字段术语，如下所示： 批次号(Batch NO.)：POS从签到起至结算、签退为止的交易为一批次，交易批次号标识一批交易。POS中心为每个POS的每个批次分配一个批次号，在签到响应报文中下传给POS终端。对应银联ISO8583报文的报文头域7：批次号(Batch Number) 序号(Ref. NO.)：POS中心为交易分配的流水号，在响应报文中下传给POS终端作为对账参考号，并用于事后查证。对应银联ISO8583报文的域37：检索参考号（Retrieval Reference Number） 授权号(Auth Code)：授权标识应答码，简称“授权码”。是发卡行返回或银联CUPS代授权时返回的授权序号。对应银联ISO8583报文的域38：授权标识应答码 Authorization Identification Response 查询号(Trace NO.)：POS机为每一笔交易产生的顺序编号。POS每上送一次交易此号码增加1。 POS流水号为6位数字，值从1至999999循环使用。在自动冲正时，POS中心依据POS流水号作为确定被冲正交易的要素之一。 凭证号(Voucher NO.)：查询号(Trace NO. 也叫POS流水号)也作为交易凭证号（在签购单上打印为Voucher NO.），在进行撤销等交易时，输入原交易凭证号作为确定原交易的要素之一，并且必须上送原交易的凭证号。 流程分析下图所示为一般的包含POS支付APP，POS终端，后台的交易流程示意图，所有的交易类型如消费、消费撤销、退货等都是这样一套流程。图中JAR是JAVA语言单独封装出来的一层，相当于APP、POS终端、后台服务器三者的媒介。当然，其他语言原理一样。 参考上图，具体步骤为： APP通过用户界面发起一项交易（消费、消费撤销、退货等）； JAR包收到交易指令后通知POS终端（二者通过串口或蓝牙进行通讯），显示交易指令并提示刷卡； 持卡人刷卡输入密码确认后，POS终端将交易请求数据打包发送给JAR包； JAR包将交易请求数据通过互联网发送给后台； 后台处理完毕后将处理结果返回给JAR包； JAR包将这一结果再次透传返回给POS终端，这一步POS终端如果接收超时，则下次交易发起时会进行自动冲正； POS机记录交易结果，并向JAR包应答，这一步JAR包如果接收超时，则需提示APP进行补登操作； JAR包将交易结果最终返回给APP。 另外，文中所出现的后台指的是收单机构的后台，收单机构又是和银联的后台对接的，那么这里需要详细解释一下。这个时候我们需要引入清算这个概念以及著名的721比例。 在一次普通的POS机交易中，可能涉及到四家机构，一是刷卡人的发卡行，二是为POS机拓展商户的收单机构（当然，POS机可能又是另外一家专门的POS机厂商生产的），三是商户账户对应的银行，四是银联。银联的清算中心作为一个桥梁，每天会对所有收单机构的交易进行清算，清算前，顾客刷卡消费的金额虽然已经从其银行卡上扣掉了，但实际上还是在该银行内部，通过银联的清算，这笔金额会通过银联到达收单机构的账户，收单机构又会再次通过银联将这笔钱转到商户所使用的银行账户上。上述的过程钱不是白转的，一般POS刷卡消费对于商户会有一定比例的手续费，如千分之六，那么这个手续费会按照持卡人发卡行：收单机构：银联=7：2：1的比例来进行分成。当然需要注意的是，收单机构既包括一些银行，也包括一些有收单支付牌照的第三方机构，当收单机构和持卡人的银行卡同属一家银行的时候，是不需要经过银联的，因此该银行可以通吃商户手续费。 需要说明的是，银行交易系统流程复杂，POS机应用模式也是多种多样，因此本文所讲内容可能只是冰山一角，不准确的地方还望大家批评指正。 转载请注明出处！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"业务","slug":"业务","permalink":"//guojinyu.com/tags/业务/"}]},{"title":"Android使用Builder模式自定义Dialog","slug":"Android使用Builder模式自定义Dialog","date":"2016-08-03T13:30:00.000Z","updated":"2017-02-21T08:42:28.000Z","comments":true,"path":"2016/08/03/Android使用Builder模式自定义Dialog/","link":"","permalink":"//guojinyu.com/2016/08/03/Android使用Builder模式自定义Dialog/","excerpt":"","text":"首先说说为啥要自定义Dialog，在任何软件操作系统中，Dialog即对话框都是一种重要的交互模式与信息载体，而Android系统本身的Dialog拥有固定的样式，并且在5.0后采用Material Design设计风格的Dialog美观大气。但是我们开发人员在实际项目过程中遇到的需求是多种多样的，有时我们要匹配APP自己的设计风格，有时我们会觉得系统的对话框使用起来不够自由，因此自己定义一个适合自己的Dialog是很有必要的。 然后为什么要用Builder模式呢，Builder设计模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。它的优点就在于将对象的构建和表示分离从而解耦。我们都知道Android系统自身的对话框如AlertDialog就采用了Builder模式，因此可见Builder模式很适合用来构建Dialog对象。 好，废话少说，上代码。 BaseDialog.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244package com.acker.android.dialog;import android.app.Dialog;import android.content.Context;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import android.widget.LinearLayout;import android.widget.ProgressBar;import android.widget.TextView;/** * 自定义Dialog基类 * * @author guojinyu */public class BaseDialog extends Dialog &#123; private TextView tvTitle; private TextView tvMsg; private ProgressBar pbLoading; private Button btnPositive; private Button btnNegative; private FrameLayout flCustom; private View.OnClickListener onDefaultClickListener = new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; cancel(); &#125; &#125;; private View.OnClickListener onPositiveListener = onDefaultClickListener; private View.OnClickListener onNegativeListener = onDefaultClickListener; private String mTitle; private String mMessage; private String positiveText; private String negativeText; private boolean isProgressBarShow = false; private boolean isNegativeBtnShow = true; private View mView; private BaseDialog(Context context) &#123; super(context, R.style.MyDialog); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.dialog_base); flCustom = (FrameLayout) findViewById(R.id.fl_dialog_content); tvTitle = (TextView) findViewById(R.id.tv_title); pbLoading = (ProgressBar) findViewById(R.id.pb_loading); tvMsg = (TextView) findViewById(R.id.tv_msg); btnPositive = (Button) findViewById(R.id.btn_positive); btnNegative = (Button) findViewById(R.id.btn_negative); &#125; /** * 调用完Builder类的create()方法后显示该对话框的方法 */ @Override public void show() &#123; super.show(); show(this); &#125; private void show(BaseDialog mDialog) &#123; if (!TextUtils.isEmpty(mDialog.mTitle)) &#123; mDialog.tvTitle.setText(mDialog.mTitle); &#125; if (mDialog.mView != null) &#123; mDialog.flCustom.addView(mDialog.mView); mDialog.pbLoading.setVisibility(View.GONE); mDialog.tvMsg.setVisibility(View.GONE); &#125; else &#123; if (!TextUtils.isEmpty(mDialog.mMessage)) &#123; mDialog.tvMsg.setText(mDialog.mMessage); mDialog.tvMsg.setVisibility(View.VISIBLE); &#125; if (isProgressBarShow) &#123; mDialog.pbLoading.setVisibility(View.VISIBLE); mDialog.btnPositive.setVisibility(View.GONE); mDialog.btnNegative.setVisibility(View.GONE); &#125; &#125; if (!mDialog.isNegativeBtnShow) &#123; mDialog.btnNegative.setVisibility(View.GONE); LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) mDialog.btnPositive .getLayoutParams(); layoutParams.setMargins(150, layoutParams.topMargin, 150, layoutParams.bottomMargin); mDialog.btnPositive.setLayoutParams(layoutParams); &#125; else &#123; mDialog.btnNegative.setOnClickListener(mDialog.onNegativeListener); if (!TextUtils.isEmpty(mDialog.negativeText)) &#123; mDialog.btnNegative.setText(mDialog.negativeText); &#125; &#125; mDialog.btnPositive.setOnClickListener(mDialog.onPositiveListener); if (!TextUtils.isEmpty(mDialog.positiveText)) &#123; mDialog.btnPositive.setText(mDialog.positiveText); &#125; &#125; public static class Builder &#123; private BaseDialog mDialog; public Builder(Context context) &#123; mDialog = new BaseDialog(context); &#125; /** * 设置对话框标题 * * @param title */ public Builder setTitle(String title) &#123; mDialog.mTitle = title; return this; &#125; /** * 设置对话框文本内容,如果调用了setView()方法，该项失效 * * @param msg */ public Builder setMessage(String msg) &#123; mDialog.mMessage = msg; return this; &#125; /** * 设置确认按钮的回调 * * @param onClickListener */ public Builder setPositiveButton(View.OnClickListener onClickListener) &#123; mDialog.onPositiveListener = onClickListener; return this; &#125; /** * 设置确认按钮的回调 * * @param btnText,onClickListener */ public Builder setPositiveButton(String btnText, View.OnClickListener onClickListener) &#123; mDialog.positiveText = btnText; mDialog.onPositiveListener = onClickListener; return this; &#125; /** * 设置取消按钮的回掉 * * @param onClickListener */ public Builder setNegativeButton(View.OnClickListener onClickListener) &#123; mDialog.onNegativeListener = onClickListener; return this; &#125; /** * 设置取消按钮的回调 * * @param btnText,onClickListener */ public Builder setNegativeButton(String btnText, View.OnClickListener onClickListener) &#123; mDialog.negativeText = btnText; mDialog.onNegativeListener = onClickListener; return this; &#125; /** * 设置手否显示ProgressBar，默认不显示 * * @param isProgressBarShow */ public Builder setProgressBarShow(boolean isProgressBarShow) &#123; mDialog.isProgressBarShow = isProgressBarShow; return this; &#125; /** * 设置是否显示取消按钮，默认显示 * * @param isNegativeBtnShow */ public Builder setNegativeBtnShow(boolean isNegativeBtnShow) &#123; mDialog.isNegativeBtnShow = isNegativeBtnShow; return this; &#125; /** * 设置自定义内容View * * @param view */ public Builder setView(View view) &#123; mDialog.mView = view; return this; &#125; /** * 设置该对话框能否被Cancel掉，默认可以 * * @param cancelable */ public Builder setCancelable(boolean cancelable) &#123; mDialog.setCancelable(cancelable); return this; &#125; /** * 设置对话框被cancel对应的回调接口，cancel()方法被调用时才会回调该接口 * * @param onCancelListener */ public Builder setOnCancelListener(OnCancelListener onCancelListener) &#123; mDialog.setOnCancelListener(onCancelListener); return this; &#125; /** * 设置对话框消失对应的回调接口，一切对话框消失都会回调该接口 * * @param onDismissListener */ public Builder setOnDismissListener(OnDismissListener onDismissListener) &#123; mDialog.setOnDismissListener(onDismissListener); return this; &#125; /** * 通过Builder类设置完属性后构造对话框的方法 */ public BaseDialog create() &#123; return mDialog; &#125; &#125;&#125; 代码很简单，BaseDialog类内定义一些对话框要显示的控件和这些控件对应的一些属性，以及最终将所有属性填入到控件的方法show()。Builder类是BaseDialog的一个内部类，其中定义了BaseDialog类的所有属性的set方法以及装配完毕后的create()方法。 对应的自定义Dialog的布局文件 dialog_base.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"20dp\" android:layout_marginRight=\"20dp\" android:background=\"@drawable/bg_base_dialog\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"10dp\" android:layout_marginTop=\"10dp\" android:gravity=\"center\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" /&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/black\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"20dp\" android:layout_marginRight=\"20dp\" android:orientation=\"horizontal\"&gt; &lt;ProgressBar android:id=\"@+id/pb_loading\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:layout_marginBottom=\"20dp\" android:layout_marginRight=\"20dp\" android:layout_marginTop=\"20dp\" android:visibility=\"gone\" /&gt; &lt;TextView android:id=\"@+id/tv_msg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginBottom=\"20dp\" android:layout_marginTop=\"20dp\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" android:visibility=\"gone\" /&gt; &lt;/LinearLayout&gt; &lt;FrameLayout android:id=\"@+id/fl_dialog_content\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt;&lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/btn_negative\" android:layout_width=\"0dp\" android:layout_height=\"40dp\" android:layout_marginBottom=\"20dp\" android:layout_marginLeft=\"20dp\" android:layout_marginRight=\"20dp\" android:layout_weight=\"1\" android:background=\"@drawable/bg_dialog_btn_negative\" android:gravity=\"center\" android:text=\"取消\" android:textColor=\"@android:color/white\" android:textSize=\"18sp\" /&gt; &lt;Button android:id=\"@+id/btn_positive\" android:layout_width=\"0dp\" android:layout_height=\"40dp\" android:layout_marginBottom=\"20dp\" android:layout_marginLeft=\"20dp\" android:layout_marginRight=\"20dp\" android:layout_weight=\"1\" android:background=\"@drawable/bg_dialog_btn_positive\" android:gravity=\"center\" android:text=\"确定\" android:textColor=\"@android:color/white\" android:textSize=\"18sp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 涉及到的其他资源文件如下： 对话框样式 styles.xml 123456789101112&lt;resources&gt; &lt;!-- 全局Dialog样式 --&gt; &lt;style name=\"MyDialog\" parent=\"@android:style/Theme.Dialog\"&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:windowFrame\"&gt;@null&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowIsFloating\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:background\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:backgroundDimEnabled\"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 通过设置这些属性可以保证对话框背景透明无黑边。 确定取消按钮的颜色值 colors.xml 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;color name=\"btn_dialog_negative_normal\"&gt;#ff0000&lt;/color&gt; &lt;color name=\"btn_dialog_negative_pressed\"&gt;#bf0000&lt;/color&gt; &lt;color name=\"btn_dialog_positive_normal\"&gt;#368bff&lt;/color&gt; &lt;color name=\"btn_dialog_positive_pressed\"&gt;#0067f3&lt;/color&gt;&lt;/resources&gt; 对话框背景 bg_base_dialog.xml 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;corners android:radius=\"4dp\" /&gt; &lt;solid android:color=\"@android:color/white\" /&gt; &lt;stroke android:width=\"1dp\" android:color=\"#e5e7ea\" /&gt;&lt;/shape&gt; 包含背景、圆角、阴影效果。 确定按钮背景 bg_dialog_btn_positive.xml 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/btn_dialog_positive_normal\" android:state_pressed=\"false\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@color/btn_dialog_positive_pressed\" android:state_pressed=\"true\"&gt;&lt;/item&gt;&lt;/selector&gt; 包含正常和按下的效果。 取消按钮背景 bg_dialog_btn_negative.xml 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/btn_dialog_negative_normal\" android:state_pressed=\"false\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@color/btn_dialog_negative_pressed\" android:state_pressed=\"true\"&gt;&lt;/item&gt;&lt;/selector&gt; 包含正常和按下的效果。 以上就是整个自定义Dialog的所有内容，接下来我们通过一个简单的Demo来演示如何使用它。 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738package com.acker.android.dialog;import android.content.DialogInterface;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; BaseDialog dialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dialog = new BaseDialog.Builder(this).setTitle(\"标题\").setMessage(\"内容\") .setPositiveButton(\"哈哈\", new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; dialog.dismiss(); &#125; &#125;).setOnCancelListener(new DialogInterface.OnCancelListener() &#123; @Override public void onCancel(DialogInterface dialogInterface) &#123; Toast.makeText(MainActivity.this, \"cancel\", Toast.LENGTH_SHORT).show(); &#125; &#125;).setOnDismissListener(new DialogInterface.OnDismissListener() &#123; @Override public void onDismiss(DialogInterface dialogInterface) &#123; Toast.makeText(MainActivity.this, \"dismiss\", Toast.LENGTH_SHORT).show(); &#125; &#125;).create(); dialog.show(); &#125;&#125; 来看下效果图： 很丑有木有，不过没关系，这里我们只是展示它的用法，如何把对话框做的好看一点就看各位的发挥了。可以看出自定义的BaseDialog的使用方法与Andorid自身的AlertDialog基本一致，都是通过其Builder类进行对象的构建。 该自定义对话框还支持显示ProgressBar以及自定义内容填充的功能。 显示ProgressBar且触摸屏幕不可取消： 12.setProgressBarShow(true).setCancelable(false) 效果图如下： 自定义内容区域且不显示取消按钮： 123View view = getLayoutInflater().inflate(R.layout.dialog_input_amount, null);final EditText amountEdit = (EditText) view.findViewById(R.id.dialog_et_amount);amountEdit.setText(\"123456789\"); 12.setView(view).setNegativeBtnShow(false) 其对应的布局文件为 dialog_input_amount.xml： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" &gt; &lt;EditText android:id=\"@+id/dialog_et_amount\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:layout_marginBottom=\"20dp\" android:layout_marginLeft=\"20dp\" android:layout_marginRight=\"20dp\" android:layout_marginTop=\"20dp\" android:gravity=\"center_vertical\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" android:inputType=\"numberDecimal\" android:singleLine=\"true\" android:textSize=\"18sp\" &gt; &lt;/EditText&gt;&lt;/LinearLayout&gt; 效果图如下： 综上，可以看出通过Builder模式自定义Dialog既可以维持原有Android对话框的使用方法，同时使用方便，自由度更高，大家完全可以按照各自的需求来对代码作出相应的修改。需要说明的是本文并没有严格按照传统的Builder设计模式来实现对话框，而是做了一些简化以更适合于我们的场景。 文中所有代码可以在个人github主页查看和下载。 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"//guojinyu.com/tags/设计模式/"}]},{"title":"Android获取设备IP地址代码与分析","slug":"Android获取设备IP地址代码与分析","date":"2016-07-26T11:00:00.000Z","updated":"2017-02-21T08:42:28.000Z","comments":true,"path":"2016/07/26/Android获取设备IP地址代码与分析/","link":"","permalink":"//guojinyu.com/2016/07/26/Android获取设备IP地址代码与分析/","excerpt":"","text":"一直以来，好像没有一段标准的代码能提供Android设备此刻的IP地址，究其原因，Android设备的网卡可能不只一个，如蜂窝网卡、WiFi网卡，而且同一个网卡也可能拥有不止一个IP地址。基于此，一个Android终端很有可能同时拥有多个IP地址（不只是同时拥有IPv4和IPv6地址），比如开启热点共享蜂窝网络的时候，蜂窝网卡拥有一个IPv4地址来访问外网，WiFi网卡拥有一个IPv4地址来作为内网的网关。 网上比较流行的获取Android设备IP地址的代码有以下几种，下面我们来一一分析一下。 1. 不可行的方法1String ipAddress = Inet4Address.getLocalHost().getHostAddress() 这个是Java提供的API，在Android上执行需要以下权限（经测试Android版本6.0.1的一部机器不需要该权限，比较纳闷，求解答）1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 此外，由于该方法使用了网络通信，因此不能在UI线程执行。 该方法顾名思义是获取本地主机的IP地址，在某些Java平台上可以得到想要的结果，但是我截取了Android官方给出的关于该方法的部分说明如下： Returns an InetAddress for the local host if possible, or the loopback address otherwise. This method works by getting the hostname, performing a DNS lookup, and then taking the first returned address.Note that if the host doesn’t have a hostname set – as Android devices typically don’t – this method will effectively return the loopback address, albeit by getting the name localhost and then doing a lookup to translate that to 127.0.0.1. 可以看出，一般在Android平台上，由于网络通信设备没有设置hostname，因此无法进行DNS检索得到其相应的IP地址，因此该方法会返回本地回环地址，即127.0.0.1，也就是说这个方法在Android平台上无法达到我们一般的获取本机IP地址的目的，经过测试，结果也确实如此。 2. 部分可行的方法123WifiManager wm = (WifiManager) getSystemService(WIFI_SERVICE);int ipAddressInt = wm.getConnectionInfo().getIpAddress();String ipAddress = String.format(Locale.getDefault(), \"%d.%d.%d.%d\", (ipAddressInt &amp; 0xff), (ipAddressInt &gt;&gt; 8 &amp; 0xff), (ipAddressInt &gt;&gt; 16 &amp; 0xff), (ipAddressInt &gt;&gt; 24 &amp; 0xff)); 方法执行所需权限为：1&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; 需要说明的是，上述代码第二行返回的是一个int类型的值，如1795336384，它对应的十六进制值6b02a8c0每两位便对应IPv4地址的每一项（逆序，如c0转化为十进制为192）。 经测试，通过该方法可以获得当前WiFi网络中Android设备的IPv4地址，但是显然，该方法是通过WifiManager获取当前网络连接下的IP地址的，因此它只局限于使用WiFi网络的情况，当使用蜂窝等其他网络设备时，该方法无效，会返回0值。另外，如果你是通过比较hacker的方式比如没有通过系统Framework层打开WiFi，而是自己通过Linux命令创建的WiFi网络,那么像这种Framework层提供的API也是不起作用的。 3. 基本可行的方法123456789101112131415161718public static String getIpAddressString() &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; enNetI = NetworkInterface .getNetworkInterfaces(); enNetI.hasMoreElements(); ) &#123; NetworkInterface netI = enNetI.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = netI .getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (inetAddress instanceof Inet4Address &amp;&amp; !inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; return \"\";&#125; 方法执行所需权限为：1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 这段代码不难理解，其实就是双重循环获取终端中所有网络接口的所有IP地址，然后返回第一个遇到的非本地回环的IPv4地址。这种方式可以很好的覆盖我们一般的需求。根据Android系统的运行机制，当WiFi网络开启时蜂窝网络会自动关闭，因此遍历到的第一个地址是WiFi网卡的IP地址；同样，当关闭WiFi网络，打开蜂窝网络时，遍历到的第一个地址是蜂窝网卡的IP地址。 那么，为什么我叫这种方式为基本可行的方法呢，因为它返回的结果并不是百分百“正确”的，确切地说并不一定是开发人员想要的结果。比如当Android手机开启热点的时候，实际上是通过WiFi网卡共享其蜂窝网络，因此此时，WiFi网卡和蜂窝网卡分配了不同的IP地址，但由于蜂窝网卡对应的NetworkInterface对象出现的位置要先于WiFi网卡，因此该方法返回的实际上是蜂窝网卡的IP地址。如果想要始终获取WiFi网卡的IP地址可以在上述的两个循环间添加如下筛选代码：1if (netI.getDisplayName().equals(\"wlan0\") || netI.getDisplayName().equals(\"eth0\")) 其中”wlan0”和”eth0”为常见的WLAN网卡的DisplayName名称，绝大部分为”wlan0”，比较老的机型可能会是”eth0”或其他。 这里只是举了一个简单的例子，其实还有很多特殊的情况，比如开启USB网络共享的情况、开启网络代理的情况、之前提到的Hacker手段同时打开蜂窝网络和WiFi网络（非WiFi热点）的情况等等，这些网络环境下都会存在多IP的情况，因此该方法不一定完全适用了。 正如文章开头所说，由于一个Android设备同一时刻可能不只有一个IP地址，因此可以说没有任何一段通用的代码能获取每个人心中想要获取的IP地址，重要的还是根据自己具体的需求来进行相应的代码修改，通过对获取的IP地址列表进行筛选来得到想要的结果。 本文的讨论是围绕IPv4地址的，如果想要获取IPv6地址，Android API也提供了相应的类或方法，只需要在上述代码的基础上作出微小修改即可。 最后附上在StackOverFlow上看到的关于IP地址筛选的总结，供大家参考。 Any address in the range 127.xxx.xxx.xxx is a “loopback” address. It is only visible to “this” host. Any address in the range 192.168.xxx.xxx is a private (aka site local) IP address. These are reserved for use within an organization. The same applies to 10.xxx.xxx.xxx addresses, and 172.16.xxx.xxx through 172.31.xxx.xxx. Addresses in the range 169.254.xxx.xxx are link local IP addresses. These are reserved for use on a single network segment. Addresses in the range 224.xxx.xxx.xxx through 239.xxx.xxx.xxx are multicast addresses. The address 255.255.255.255 is the broadcast address. Anything else should be a valid public point-to-point IPv4 address. 文中所有代码可以在个人github主页查看和下载。 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"//guojinyu.com/tags/Java/"}]},{"title":"Java中String和byte[]间的转换浅析","slug":"Java中String和byte[]间的转换浅析","date":"2016-06-21T06:00:00.000Z","updated":"2017-02-21T08:42:28.000Z","comments":true,"path":"2016/06/21/Java中String和byte[]间的转换浅析/","link":"","permalink":"//guojinyu.com/2016/06/21/Java中String和byte[]间的转换浅析/","excerpt":"","text":"Java语言中字符串类型和字节数组类型相互之间的转换经常发生，网上的分析及代码也比较多，本文将分析总结常规的byte[]和String间的转换以及十六进制String和byte[]间相互转换的原理及实现。 1. String转byte[]首先我们来分析一下常规的String转byte[]的方法，代码如下：1234567public static byte[] strToByteArray(String str) &#123; if (str == null) &#123; return null; &#125; byte[] byteArray = str.getBytes(); return byteArray;&#125; 很简单，就是调用String类的getBytes()方法。看JDK源码可以发现该方法最终调用了String类如下的方法。12345678910111213141516171819/* JDK source code */public byte[] getBytes(Charset charset) &#123; String canonicalCharsetName = charset.name(); if (canonicalCharsetName.equals(\"UTF-8\")) &#123; return Charsets.toUtf8Bytes(value, offset, count); &#125; else if (canonicalCharsetName.equals(\"ISO-8859-1\")) &#123; return Charsets.toIsoLatin1Bytes(value, offset, count); &#125; else if (canonicalCharsetName.equals(\"US-ASCII\")) &#123; return Charsets.toAsciiBytes(value, offset, count); &#125; else if (canonicalCharsetName.equals(\"UTF-16BE\")) &#123; return Charsets.toBigEndianUtf16Bytes(value, offset, count); &#125; else &#123; CharBuffer chars = CharBuffer.wrap(this.value, this.offset, this.count); ByteBuffer buffer = charset.encode(chars.asReadOnlyBuffer()); byte[] bytes = new byte[buffer.limit()]; buffer.get(bytes); return bytes; &#125;&#125; 上述代码其实就是根据给定的编码方式进行编码。如果调用的是不带参数的getBytes()方法，则使用默认的编码方式，如下代码所示：123456789/* JDK source code */private static Charset getDefaultCharset() &#123; String encoding = System.getProperty(\"file.encoding\", \"UTF-8\"); try &#123; return Charset.forName(encoding); &#125; catch (UnsupportedCharsetException e) &#123; return Charset.forName(\"UTF-8\"); &#125;&#125; 关于默认的编码方式，Java API是这样说的： The default charset is determined during virtual-machine startup and typically depends upon the locale and charset of the underlying operating system. 同样，由上述代码可以看出，默认编码方式是由System类的”file.encoding”属性决定的，经过测试，在简体中文Windows操作系统下，默认编码方式为”GBK”，在Android平台上，默认编码方式为”UTF-8”。 2. byte[]转String接下来分析一下常规的byte[]转为String的方法，代码如下：1234567public static String byteArrayToStr(byte[] byteArray) &#123; if (byteArray == null) &#123; return null; &#125; String str = new String(byteArray); return str;&#125; 很简单，就是String的构造方法之一。那我们分析Java中String的源码，可以看出所有以byte[]为参数的构造方法最终都调用了如下代码所示的构造方法。需要注意的是Java中String类的数据是Unicode类型的，因此上述的getBytes()方法是把Unicode类型转化为指定编码方式的byte数组；而这里的Charset为读取该byte数组时所使用的编码方式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* JDK source code */public String(byte[] data, int offset, int byteCount, Charset charset) &#123; if ((offset | byteCount) &lt; 0 || byteCount &gt; data.length - offset) &#123; throw failedBoundsCheck(data.length, offset, byteCount); &#125; // We inline UTF-8, ISO-8859-1, and US-ASCII decoders for speed and because // 'count' and 'value' are final. String canonicalCharsetName = charset.name(); if (canonicalCharsetName.equals(\"UTF-8\")) &#123; byte[] d = data; char[] v = new char[byteCount]; int idx = offset; int last = offset + byteCount; int s = 0; outer: while (idx &lt; last) &#123; byte b0 = d[idx++]; if ((b0 &amp; 0x80) == 0) &#123; // 0xxxxxxx // Range: U-00000000 - U-0000007F int val = b0 &amp; 0xff; v[s++] = (char) val; &#125; else if (((b0 &amp; 0xe0) == 0xc0) || ((b0 &amp; 0xf0) == 0xe0) || ((b0 &amp; 0xf8) == 0xf0) || ((b0 &amp; 0xfc) == 0xf8) || ((b0 &amp; 0xfe) == 0xfc)) &#123; int utfCount = 1; if ((b0 &amp; 0xf0) == 0xe0) utfCount = 2; else if ((b0 &amp; 0xf8) == 0xf0) utfCount = 3; else if ((b0 &amp; 0xfc) == 0xf8) utfCount = 4; else if ((b0 &amp; 0xfe) == 0xfc) utfCount = 5; // 110xxxxx (10xxxxxx)+ // Range: U-00000080 - U-000007FF (count == 1) // Range: U-00000800 - U-0000FFFF (count == 2) // Range: U-00010000 - U-001FFFFF (count == 3) // Range: U-00200000 - U-03FFFFFF (count == 4) // Range: U-04000000 - U-7FFFFFFF (count == 5) if (idx + utfCount &gt; last) &#123; v[s++] = REPLACEMENT_CHAR; continue; &#125; // Extract usable bits from b0 int val = b0 &amp; (0x1f &gt;&gt; (utfCount - 1)); for (int i = 0; i &lt; utfCount; ++i) &#123; byte b = d[idx++]; if ((b &amp; 0xc0) != 0x80) &#123; v[s++] = REPLACEMENT_CHAR; idx--; // Put the input char back continue outer; &#125; // Push new bits in from the right side val &lt;&lt;= 6; val |= b &amp; 0x3f; &#125; // Note: Java allows overlong char // specifications To disallow, check that val // is greater than or equal to the minimum // value for each count: // // count min value // ----- ---------- // 1 0x80 // 2 0x800 // 3 0x10000 // 4 0x200000 // 5 0x4000000 // Allow surrogate values (0xD800 - 0xDFFF) to // be specified using 3-byte UTF values only if ((utfCount != 2) &amp;&amp; (val &gt;= 0xD800) &amp;&amp; (val &lt;= 0xDFFF)) &#123; v[s++] = REPLACEMENT_CHAR; continue; &#125; // Reject chars greater than the Unicode maximum of U+10FFFF. if (val &gt; 0x10FFFF) &#123; v[s++] = REPLACEMENT_CHAR; continue; &#125; // Encode chars from U+10000 up as surrogate pairs if (val &lt; 0x10000) &#123; v[s++] = (char) val; &#125; else &#123; int x = val &amp; 0xffff; int u = (val &gt;&gt; 16) &amp; 0x1f; int w = (u - 1) &amp; 0xffff; int hi = 0xd800 | (w &lt;&lt; 6) | (x &gt;&gt; 10); int lo = 0xdc00 | (x &amp; 0x3ff); v[s++] = (char) hi; v[s++] = (char) lo; &#125; &#125; else &#123; // Illegal values 0x8*, 0x9*, 0xa*, 0xb*, 0xfd-0xff v[s++] = REPLACEMENT_CHAR; &#125; &#125; if (s == byteCount) &#123; // We guessed right, so we can use our temporary array as-is. this.offset = 0; this.value = v; this.count = s; &#125; else &#123; // Our temporary array was too big, so reallocate and copy. this.offset = 0; this.value = new char[s]; this.count = s; System.arraycopy(v, 0, value, 0, s); &#125; &#125; else if (canonicalCharsetName.equals(\"ISO-8859-1\")) &#123; this.offset = 0; this.value = new char[byteCount]; this.count = byteCount; Charsets.isoLatin1BytesToChars(data, offset, byteCount, value); &#125; else if (canonicalCharsetName.equals(\"US-ASCII\")) &#123; this.offset = 0; this.value = new char[byteCount]; this.count = byteCount; Charsets.asciiBytesToChars(data, offset, byteCount, value); &#125; else &#123; CharBuffer cb = charset.decode(ByteBuffer.wrap(data, offset, byteCount)); this.offset = 0; this.count = cb.length(); if (count &gt; 0) &#123; // We could use cb.array() directly, but that would mean we'd have to trust // the CharsetDecoder doesn't hang on to the CharBuffer and mutate it later, // which would break String's immutability guarantee. It would also tend to // mean that we'd be wasting memory because CharsetDecoder doesn't trim the // array. So we copy. this.value = new char[count]; System.arraycopy(cb.array(), 0, value, 0, count); &#125; else &#123; this.value = EmptyArray.CHAR; &#125; &#125;&#125; 具体的转换过程较为复杂，其实就是将byte数组的一个或多个元素按指定的Charset类型读取并转换为char类型（char本身就是以Unicode编码方式存储的），因为String类的核心是其内部维护的char数组。因此有兴趣的同学可以研究下各种编码方式的编码规则，然后才能看懂具体的转换过程。 3. byte[]转十六进制String所谓十六进制String，就是字符串里面的字符都是十六进制形式，因为一个byte是八位，可以用两个十六进制位来表示，因此，byte数组中的每个元素可以转换为两个十六进制形式的char，所以最终的HexString的长度是byte数组长度的两倍。闲话少说上代码：12345678910111213public static String byteArrayToHexStr(byte[] byteArray) &#123; if (byteArray == null)&#123; return null; &#125; char[] hexArray = \"0123456789ABCDEF\".toCharArray(); char[] hexChars = new char[byteArray.length * 2]; for (int j = 0; j &lt; byteArray.length; j++) &#123; int v = byteArray[j] &amp; 0xFF; hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4]; hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F]; &#125; return new String(hexChars);&#125; 上述代码中，之所以要将byte数值和0xFF按位与，是因为我们为了方便后面的无符号移位操作（无符号右移运算符&gt;&gt;&gt;只对32位和64位的值有意义），要将byte数据转换为int类型，而如果直接转换就会出现问题。因为java里面二进制是以补码形式存在的，如果直接转换，位扩展会产生问题，如值为-1的byte存储的二进制形式为其补码11111111，而转换为int后为11111111111111111111111111111111，直接使用该值结果就不对了。而0xFF默认是int类型，即0x000000FF，一个byte值跟0xFF相与会先将那个byte值转化成int类型运算，这样，相与的结果中高的24个比特就总会被清0，后面的运算才会正确。 4. 十六进制String转byte[]没什么好说的了，就是byte[]转十六进制String的逆过程，放代码：123456789101112131415public static byte[] hexStrToByteArray(String str)&#123; if (str == null) &#123; return null; &#125; if (str.length() == 0) &#123; return new byte[0]; &#125; byte[] byteArray = new byte[str.length() / 2]; for (int i = 0; i &lt; byteArray.length; i++)&#123; String subStr = str.substring(2 * i, 2 * i + 2); byteArray[i] = ((byte)Integer.parseInt(subStr, 16)); &#125; return byteArray;&#125; 文中所有代码可以在个人github主页查看和下载。 另，转载请注明出处！文中若有什么错误希望大家探讨指正！","categories":[{"name":"技术","slug":"技术","permalink":"//guojinyu.com/categories/技术/"}],"tags":[{"name":"Android","slug":"Android","permalink":"//guojinyu.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"//guojinyu.com/tags/Java/"}]}]}